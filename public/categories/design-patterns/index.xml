<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design Patterns on My New Hugo Site</title>
    <link>http://localhost:1313/categories/design-patterns/</link>
    <description>Recent content in Design Patterns on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Aug 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Command Pattern in Kotlin</title>
      <link>http://localhost:1313/kotlin-command-pattern/</link>
      <pubDate>Sun, 22 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-command-pattern/</guid>
      <description>Purpose The Command pattern wraps the request into a specific object that has all the information necessary to perform its task. You can think of it as the next stage of refactoring, where at first we extract the code to a separate method, and then to a separate object, taking the arguments needed to execute the request in the constructor.&#xA;Since the request is an object, it can be sent to a separate object (CommandProcessor) for execution, which allows for their queuing and facilitates logging events.</description>
    </item>
    <item>
      <title>Mediator in Kotlin</title>
      <link>http://localhost:1313/kotlin_mediator_pattern/</link>
      <pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin_mediator_pattern/</guid>
      <description>Purpose We define a Mediator as an object encapsulating interactions between other objects (components) from a given set. The pattern limits, or even cuts off completely, direct dependencies between classes. Components can only communicate with each other through the Mediator, which becomes the central hub for information and control. The Mediator controls the flow of information using its internal logic.&#xA;This can be compared to the air traffic control tower (ATC).</description>
    </item>
    <item>
      <title>Decorator Pattern in Kotlin</title>
      <link>http://localhost:1313/kotlin-decorator-pattern/</link>
      <pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-decorator-pattern/</guid>
      <description>Purpose The Decorator allows you to dynamically add or change the behavior of a specific object of a given class, without affecting other objects of the same class. In some cases, this allows you to significantly reduce the number of classes by moving the shared behavior to the Decorator, rather than extending the inheritance structure.&#xA;The decorator&amp;rsquo;s job is to &amp;ldquo;wrap&amp;rdquo; (hence another name: &amp;ldquo;Wrapper&amp;rdquo;) the original object and modify or overwrite its behavior.</description>
    </item>
    <item>
      <title>Adapter Pattern in Kotlin</title>
      <link>http://localhost:1313/kotlin-adapter-pattern/</link>
      <pubDate>Sat, 26 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-adapter-pattern/</guid>
      <description>Purpose As the name suggests, the Adapter pattern transforms the class interface to another one requested by the client. Using the Adapter allows incompatible classes to interact with each other. Another term for this pattern is Wrapper.&#xA;The adapter allows you to &amp;ldquo;map&amp;rdquo; an adapted interface (Adaptee) to the expected interface (Target) by the client class without adding another level of inheritance. Such inheritance would not always be possible if Target was a class rather than an interface.</description>
    </item>
    <item>
      <title>Facade Pattern in Kotlin</title>
      <link>http://localhost:1313/kotlin-facade-pattern/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-facade-pattern/</guid>
      <description>Purpose The facade is a very basic pattern, whose task is to obscure the details of a group of classes - the module responsible for some functionality.&#xA;This can be compared to the facade of the building, which in itself has no function. The building consists of rooms, corridors, stairs, installations. It is the facade that indicates the entrance to the building, and the appearance may suggest its purpose.&#xA;The purpose of the pattern is to simplify customer access to the functionality of the obscured module.</description>
    </item>
    <item>
      <title>Strategy Pattern in Kotlin</title>
      <link>http://localhost:1313/kotlin-strategy-pattern/</link>
      <pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-strategy-pattern/</guid>
      <description>Purpose The Strategy design pattern defines a family of algorithms and allows them to be used interchangeably. By algorithm, here I mean any logic, be it sorting, searching, or computing some value from data. It does not matter. It is, in a sense, an extension of the Template Method pattern, but inversely to it, Strategy prefers composition over inheritance. Strategies do not inherit from any specific class but only implement a common interface.</description>
    </item>
    <item>
      <title>Kotlin Template Method</title>
      <link>http://localhost:1313/kotlin-template-method/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-template-method/</guid>
      <description>Purpose The template method is a very simple design pattern, that separates the shared class parts from distinctive ones. The core idea is to have an abstract parent class containing the algorithm steps and allowing inheriting classes to overwrite individual steps, but not the algorithm that uses those steps itself.&#xA;Think about Pizza - steps to make it are more-less the same, despite the type of pizza. You need to make a dough, apply sauce and ingredients, and finally bake it.</description>
    </item>
    <item>
      <title>Kotlin Abstract Factory</title>
      <link>http://localhost:1313/kotlin-abstract-factory/</link>
      <pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-abstract-factory/</guid>
      <description>Purpose The name of this pattern doesn&amp;rsquo;t suggest directly how it differs from other construction patterns, like Builder or Factory Method. In the Abstract Factory it&amp;rsquo;s not about creating a single object instance, but the whole family of connected objects. It still sounds like an ordinary Factory that can produce GUI controls for example. To have the Abstract Factory you should add another layer of abstraction and have a mechanism for creating GUI controls in few variants, like for Linux, Windows, or MacOS, but still have a generic API for the pattern client.</description>
    </item>
    <item>
      <title>Kotlin Factory Method</title>
      <link>http://localhost:1313/kotlin-factory-method/</link>
      <pubDate>Fri, 26 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-factory-method/</guid>
      <description>Purpose Just like Builder, the Factory is a creational pattern. It describes an interface used to deliver instances. Instead of calling object constructor, we can call a method of the Factory which will generate interface implementation - the concrete object. What makes it different from Builder is that usually none or very few arguments need to be passed. It&amp;rsquo;s Factory&amp;rsquo;s job to fulfill all required by the object dependencies.&#xA;Factory can deliver objects of various types implementing the same interface just by the passed arguments.</description>
    </item>
    <item>
      <title>Kotlin Static Factory Methods</title>
      <link>http://localhost:1313/kotlin-static-factory-methods/</link>
      <pubDate>Sun, 14 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-static-factory-methods/</guid>
      <description>Purpose There is a concise error in the title, there are no static methods in Kotlin. But there are ways to achieve similar behavior to proposed by Joshua Bloch in Effective Java book - using static factory methods instead of constructors. This is also completely different from the Factory Method design pattern, don&amp;rsquo;t confuse those.&#xA;Long story short, these are methods that create object instances based on supplied arguments (or even without them) and that you can call from anywhere without the need of having an instance of a class that contains them.</description>
    </item>
    <item>
      <title>Kotlin Builder Pattern</title>
      <link>http://localhost:1313/kotlin-builder-pattern/</link>
      <pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kotlin-builder-pattern/</guid>
      <description>Purpose Builder pattern is used to simplify creating complex objects with non-trivial building logic, or with many constructor parameters. It allows making immutable objects because all properties can be set by the Builder with no need to use object setters.&#xA;Builder sort of removes from the user the need to understand the internal object create implementation and guarantees correct object setup or returning an error.&#xA;The advantage of using Builder over traditional constructor is being able to pass many vararg arguments, because every Builder method can take one, while the whole constructor can take only one.</description>
    </item>
  </channel>
</rss>
